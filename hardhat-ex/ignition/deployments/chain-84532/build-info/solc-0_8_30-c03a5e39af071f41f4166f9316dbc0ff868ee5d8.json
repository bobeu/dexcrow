{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-c03a5e39af071f41f4166f9316dbc0ff868ee5d8",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/escrow/EscrowFactory.sol": "project/contracts/escrow/EscrowFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/escrow/Escrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.30;\r\n\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport { IEscrow } from \"../interfaces/IEscrow.sol\";\r\nimport { IEscrowFactory } from \"../interfaces/IEscrowFactory.sol\";\r\n\r\n/**\r\n * @title Escrow Smart Contract\r\n * @dev A comprehensive decentralized escrow contract for secure peer-to-peer transactions\r\n * \r\n * This contract implements a multi-state escrow system that supports:\r\n * - ETH and ERC20 token transactions\r\n * - Dispute resolution with arbiters\r\n * - Authorized agent functionality\r\n * - Platform fee collection\r\n * - Emergency pause and withdrawal mechanisms\r\n * \r\n * The contract follows a state machine pattern with the following states:\r\n * 1. AWAITING_DEPOSIT: Initial state, waiting for buyer to deposit funds\r\n * 2. AWAITING_FULFILLMENT: Funds deposited, waiting for seller to fulfill obligations\r\n * 3. DISPUTE_RAISED: A dispute has been raised and is awaiting arbiter resolution\r\n * 4. COMPLETED: Transaction completed successfully, funds released to seller\r\n * 5. CANCELED: Transaction canceled, funds refunded to buyer\r\n * \r\n * @author @bobeu : https://github.com/bobeu\r\n */\r\ncontract Escrow is IEscrow, ReentrancyGuard, Ownable, Pausable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ STATE VARIABLES ============\r\n    \r\n    /**\r\n     * @dev Main escrow data structure containing all transaction details\r\n     * Includes escrow details, dispute information, fee settings, and platform recipient\r\n     */\r\n    EscrowData public data;\r\n    \r\n    /**\r\n     * @dev Mapping of authorized agents who can perform certain actions on behalf of parties\r\n     * Agents can deposit funds, confirm fulfillment, and resolve disputes\r\n     * Only the contract owner (buyer) can authorize/revoke agents\r\n     */\r\n    mapping(address => bool) public authorizedAgents;\r\n\r\n    // ============ MODIFIERS ============\r\n    \r\n    /**\r\n     * @dev Restricts function access to only the buyer or seller\r\n     * Used for functions that either party can call (e.g., raising disputes)\r\n     */\r\n    modifier onlyParties() {\r\n        if (_msgSender() != data.escrowDetails.buyer && _msgSender() != data.escrowDetails.seller) {\r\n            revert OnlyBuyerOrSellerCanCall();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Restricts function access to only the buyer\r\n     * Used for buyer-specific actions like depositing funds and confirming fulfillment\r\n     */\r\n    modifier onlyBuyer() {\r\n        if (_msgSender() != data.escrowDetails.buyer) revert OnlyBuyerCanCall();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Restricts function access to only the seller\r\n     * Used for seller-specific actions (currently not used but available for future features)\r\n     */\r\n    modifier onlySeller() {\r\n        if (_msgSender() != data.escrowDetails.seller) revert OnlySellerCanCall();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Restricts function access to only the designated arbiter\r\n     * Used for dispute resolution functions\r\n     */\r\n    modifier onlyArbiter() {\r\n        if (_msgSender() != data.escrowDetails.arbiter) revert OnlyArbiterCanCall();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Restricts function access to only authorized agents\r\n     * Agents can perform certain actions on behalf of the buyer\r\n     */\r\n    modifier onlyAuthorizedAgent() {\r\n        if (!authorizedAgents[_msgSender()]) revert OnlyAuthorizedAgentsCanCall();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures the escrow is in the specified state\r\n     * @param _state The required escrow state for the function to execute\r\n     */\r\n    modifier validState(EscrowState _state) {\r\n        if (data.escrowDetails.state != _state) revert InvalidEscrowState();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures the escrow has not expired\r\n     * Prevents actions on expired escrows\r\n     */\r\n    modifier notExpired() {\r\n        if (_now() > data.escrowDetails.deadline) revert EscrowHasExpired();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures the escrow has expired\r\n     * Used for functions that should only work on expired escrows (e.g., refunds)\r\n     */\r\n    modifier expired() {\r\n        if (_now() <= data.escrowDetails.deadline) revert EscrowHasNotExpired();\r\n        _;\r\n    }\r\n\r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    /**\r\n     * @dev Initializes a new escrow contract with the specified parameters\r\n     * @param _buyer Address of the buyer who will deposit funds\r\n     * @param _seller Address of the seller who will fulfill the transaction\r\n     * @param _assetToken Address of the ERC20 token (address(0) for ETH)\r\n     * @param _assetAmount Amount of tokens/ETH to be escrowed\r\n     * @param _deadline Unix timestamp when the escrow expires\r\n     * @param _description Human-readable description of the transaction\r\n     * @param _disputeWindowHours Hours after deadline when disputes can still be raised\r\n     * @param _platformFeeRecipient Address that will receive platform fees\r\n     * \r\n     * The constructor performs comprehensive validation and initializes:\r\n     * - Escrow details with all transaction parameters\r\n     * - Platform fee settings (0.5% platform, 1% arbiter)\r\n     * - Initial state as AWAITING_DEPOSIT\r\n     * - Dispute information structure\r\n     * \r\n     * Emits EscrowCreated event upon successful initialization\r\n     */\r\n    constructor(\r\n        address _buyer,\r\n        address _seller,\r\n        address _assetToken,\r\n        uint256 _assetAmount,\r\n        uint256 _deadline,\r\n        string memory _description,\r\n        uint256 _disputeWindowHours,\r\n        address _platformFeeRecipient\r\n    ) Ownable(_msgSender()) {\r\n        // Validate all input parameters\r\n        if (_buyer == address(0)) revert InvalidBuyerAddress();\r\n        if (_seller == address(0)) revert InvalidSellerAddress();\r\n        if (_assetAmount == 0) revert AssetAmountMustBeGreaterThanZero();\r\n        if (_deadline <= _now()) revert DeadlineMustBeInTheFuture();\r\n        if (_disputeWindowHours == 0) revert DisputeWindowMustBeGreaterThanZero();\r\n        if (_platformFeeRecipient == address(0)) revert InvalidPlatformFeeRecipient();\r\n\r\n        // Initialize escrow details\r\n        data.escrowDetails = EscrowDetails({\r\n            buyer: _buyer,\r\n            seller: _seller,\r\n            arbiter: address(0),\r\n            assetToken: _assetToken,\r\n            assetAmount: _assetAmount,\r\n            deadline: _deadline,\r\n            state: EscrowState.AWAITING_DEPOSIT,\r\n            createdAt: _now(),\r\n            updatedAt: _now(),\r\n            description: _description,\r\n            disputeWindowHours: _disputeWindowHours\r\n        });\r\n\r\n        // Initialize fee settings\r\n        data.platformFeeRecipient = _platformFeeRecipient;\r\n        data.platformFeePercentage = 50; // 0.5%\r\n        data.arbiterFeePercentage = 100; // 1%\r\n        data.feeDenominator = 10000; // 10000 = 100%\r\n        \r\n        // Emit creation event\r\n        emit EscrowCreated(\r\n            _buyer,\r\n            _seller,\r\n            address(0),\r\n            _assetToken,\r\n            _assetAmount,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /**@dev Receive function for ETH deposits\r\n     * @notice This function allows the contract to receive ETH\r\n     * The actual deposit logic is handled in the deposit() function\r\n     */\r\n    receive() external payable {}\r\n\r\n    // ============ UTILITY FUNCTIONS ============\r\n    \r\n    /**\r\n     * @dev Returns the current block timestamp\r\n     * @return currentTime The current block timestamp\r\n     * \r\n     * This function provides a consistent way to get the current time\r\n     * and can be overridden for testing purposes\r\n     */\r\n    function _now() internal view returns(uint currentTime) {\r\n        currentTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Encodes a string to bytes format for storage efficiency\r\n     * @param reason The string to encode\r\n     * @return encoded The encoded bytes representation\r\n     * \r\n     * This function is used to store string data more efficiently\r\n     * by converting it to bytes format\r\n     */\r\n    function _encodeString(string memory reason) internal pure returns(bytes memory encoded) {\r\n        encoded = abi.encode(bytes(reason));\r\n    }\r\n\r\n    function becomeArbiter() external returns(bool) {\r\n        address sender = _msgSender();\r\n        if(!IEscrowFactory(owner()).isApprovedArbiter(sender, 1)) revert NotApproved();\r\n        if(sender == data.escrowDetails.arbiter) revert CallerIsTheArbiter();\r\n        if(data.escrowDetails.arbiter != address(0)) {\r\n            if(data.disputeInfo.isActive) {\r\n                if(_now() < data.disputeInfo.raisedAt) revert ArbiterSwapWindowNotOpen();\r\n            } else {\r\n                if(data.disputeInfo.resolvedAt > 0) revert EscrowWasResolved();\r\n            }\r\n        }\r\n        \r\n        emit ArbiterSwapped(data.escrowDetails.arbiter, sender);\r\n        data.escrowDetails.arbiter = sender;\r\n\r\n        return true;\r\n    }\r\n\r\n    // External Functions\r\n\r\n    /**\r\n     * @dev Deposit assets into escrow\r\n     * @notice Only buyer can deposit assets\r\n     */\r\n    function deposit() \r\n        external \r\n        payable \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyBuyer\r\n        validState(EscrowState.AWAITING_DEPOSIT)\r\n        notExpired\r\n    {\r\n        if (data.escrowDetails.assetToken == address(0)) {\r\n            // Native token (ETH)\r\n            if (msg.value < data.escrowDetails.assetAmount) revert IncorrectETHAmount();\r\n        } else {\r\n            // ERC20 token\r\n            if (msg.value != 0) revert ETHNotAcceptedForERC20Escrow();\r\n            IERC20 token = IERC20(data.escrowDetails.assetToken);\r\n            if (token.balanceOf(_msgSender()) < data.escrowDetails.assetAmount) {\r\n                revert InsufficientTokenBalance();\r\n            }\r\n            if (token.allowance(_msgSender(), address(this)) < data.escrowDetails.assetAmount) {\r\n                revert InsufficientTokenAllowance();\r\n            }\r\n            \r\n            token.safeTransferFrom(_msgSender(), address(this), data.escrowDetails.assetAmount);\r\n        }\r\n\r\n        data.escrowDetails.state = EscrowState.AWAITING_FULFILLMENT;\r\n        uint currentTime = _now();\r\n        data.escrowDetails.updatedAt = currentTime;\r\n\r\n        emit AssetDeposited(\r\n            _msgSender(),\r\n            data.escrowDetails.assetToken,\r\n            data.escrowDetails.assetAmount,\r\n            currentTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Confirm fulfillment and release funds to seller\r\n     * @notice Only buyer can confirm fulfillment\r\n     */\r\n    function confirmFulfillment() \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyBuyer\r\n        validState(EscrowState.AWAITING_FULFILLMENT)\r\n        notExpired\r\n    {\r\n        _releaseFunds(data.escrowDetails.seller);\r\n        \r\n        emit FulfillmentConfirmed(_msgSender(), _now());\r\n    }\r\n\r\n    /**\r\n     * @dev Release funds to seller (arbiter can also call this)\r\n     * @notice Can be called by buyer or arbiter\r\n     */\r\n    function releaseFunds() \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        validState(EscrowState.AWAITING_FULFILLMENT)\r\n        notExpired\r\n    {\r\n        if (_msgSender() != data.escrowDetails.buyer && _msgSender() != data.escrowDetails.arbiter) {\r\n            revert OnlyBuyerOrArbiterCanReleaseFunds();\r\n        }\r\n        \r\n        _releaseFunds(data.escrowDetails.seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Refund funds to buyer\r\n     * @notice Can be called by buyer (after deadline) or arbiter\r\n     */\r\n    function refundFunds() \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        validState(EscrowState.AWAITING_FULFILLMENT)\r\n    {\r\n        if (_msgSender() != data.escrowDetails.buyer && _msgSender() != data.escrowDetails.arbiter) {\r\n            revert OnlyBuyerOrArbiterCanRefundFunds();\r\n        }\r\n        \r\n        if (_msgSender() == data.escrowDetails.buyer) {\r\n            if (_now() <= data.escrowDetails.deadline) revert DeadlineNotReached();\r\n        }\r\n        \r\n        _releaseFunds(data.escrowDetails.buyer);\r\n    }\r\n\r\n    /**\r\n     * @dev Raise a dispute\r\n     * @param _reason Reason for the dispute\r\n     * @notice Only buyer or seller can raise disputes\r\n     */\r\n    function raiseDispute(string memory _reason) \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyParties\r\n        validState(EscrowState.AWAITING_FULFILLMENT)\r\n        notExpired\r\n    {\r\n        if (bytes(_reason).length == 0) revert DisputeReasonCannotBeEmpty();\r\n        uint currentTime = _now();\r\n        data.escrowDetails.state = EscrowState.DISPUTE_RAISED;\r\n        data.escrowDetails.updatedAt = currentTime;\r\n        \r\n        data.disputeInfo = DisputeInfo({\r\n            isActive: true,\r\n            disputer: _msgSender(),\r\n            reason: _encodeString(_reason),\r\n            raisedAt: currentTime,\r\n            arbiter: data.escrowDetails.arbiter,\r\n            arbiterDecision: false,\r\n            arbiterReasoning: _encodeString(\"NA\"),\r\n            resolvedAt: 0\r\n        });  \r\n\r\n        emit DisputeRaised(_msgSender(), _reason, currentTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Resolve dispute (arbiter only)\r\n     * @param _releazeFunds True to release funds to seller, false to refund to buyer\r\n     * @param _reasoning Reasoning for the decision\r\n     */\r\n    function resolveDispute(bool _releazeFunds, string memory _reasoning) \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyArbiter\r\n        validState(EscrowState.DISPUTE_RAISED)\r\n    {\r\n        if (!data.disputeInfo.isActive) revert NoActiveDispute();\r\n        if (bytes(_reasoning).length == 0) revert ReasoningCannotBeEmpty();\r\n        \r\n        uint currentTime = _now();\r\n        data.disputeInfo.arbiterDecision = _releazeFunds;\r\n        data.disputeInfo.arbiterReasoning = _encodeString(_reasoning);\r\n        data.disputeInfo.resolvedAt = currentTime;\r\n        data.disputeInfo.isActive = false;\r\n        \r\n        data.escrowDetails.updatedAt = currentTime;\r\n\r\n        if (_releazeFunds) {\r\n            _releaseFunds(data.escrowDetails.seller);\r\n        } else {\r\n            _releaseFunds(data.escrowDetails.buyer);\r\n        }\r\n\r\n        emit DisputeResolved(_msgSender(), _releazeFunds, _reasoning, currentTime);\r\n    }\r\n\r\n    // Agent Functions\r\n\r\n    /**\r\n     * @dev Deposit assets via authorized agent\r\n     * @notice Only authorized agents can call this\r\n     */\r\n    function agentDeposit() \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyAuthorizedAgent\r\n        validState(EscrowState.AWAITING_DEPOSIT)\r\n        notExpired\r\n    {\r\n        uint currentTime = _now();\r\n        data.escrowDetails.state = EscrowState.AWAITING_FULFILLMENT;\r\n        data.escrowDetails.updatedAt = currentTime;\r\n\r\n        emit AssetDeposited(\r\n            data.escrowDetails.buyer,\r\n            data.escrowDetails.assetToken,\r\n            data.escrowDetails.assetAmount,\r\n            currentTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Confirm fulfillment via authorized agent\r\n     * @notice Only authorized agents can call this\r\n     */\r\n    function agentConfirmFulfillment() \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyAuthorizedAgent\r\n        validState(EscrowState.AWAITING_FULFILLMENT)\r\n        notExpired\r\n    {\r\n        _releaseFunds(data.escrowDetails.seller);\r\n        \r\n        emit FulfillmentConfirmed(_msgSender(), _now());\r\n    }\r\n\r\n    /**\r\n     * @dev Resolve dispute via authorized agent\r\n     * @param _releazeFunds True to release funds to seller, false to refund to buyer\r\n     * @param _reasoning Reasoning for the decision\r\n     */\r\n    function agentResolveDispute(bool _releazeFunds, string memory _reasoning) \r\n        external \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyAuthorizedAgent\r\n        validState(EscrowState.DISPUTE_RAISED)\r\n    {\r\n        if (!data.disputeInfo.isActive) revert NoActiveDispute();\r\n        if (bytes(_reasoning).length == 0) revert ReasoningCannotBeEmpty();\r\n        \r\n        uint currentTime = _now();\r\n        data.disputeInfo.arbiterDecision = _releazeFunds;\r\n        data.disputeInfo.arbiterReasoning = _encodeString(_reasoning);\r\n        data.disputeInfo.resolvedAt = currentTime;\r\n        data.disputeInfo.isActive = false;\r\n        \r\n        data.escrowDetails.updatedAt = currentTime;\r\n\r\n        if (_releazeFunds) {\r\n            _releaseFunds(data.escrowDetails.seller);\r\n        } else {\r\n            _releaseFunds(data.escrowDetails.buyer);\r\n        }\r\n\r\n        emit DisputeResolved(_msgSender(), _releazeFunds, _reasoning, currentTime);\r\n    }\r\n \r\n    // View Functions\r\n\r\n    /**\r\n     * @dev Get escrow data\r\n     */\r\n    function getEscrowData() external view returns (EscrowData memory) {\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if escrow is expired\r\n     */\r\n    function isExpired() external view returns (bool) {\r\n        return _now() > data.escrowDetails.deadline;\r\n    }\r\n\r\n    /**\r\n     * @dev Get contract balance\r\n     */\r\n    function getBalance() external view returns (uint256) {\r\n        if (data.escrowDetails.assetToken == address(0)) {\r\n            return address(this).balance;\r\n        } else {\r\n            return IERC20(data.escrowDetails.assetToken).balanceOf(address(this));\r\n        }\r\n    } \r\n\r\n    // Admin Functions\r\n\r\n    /**\r\n     * @dev Authorize an agent\r\n     * @param _agent Agent address to authorize\r\n     */\r\n    function authorizeAgent(address _agent) external onlyOwner {\r\n        if (_agent == address(0)) revert InvalidAgentAddress();\r\n        authorizedAgents[_agent] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke agent authorization\r\n     * @param _agent Agent address to revoke\r\n     */\r\n    function revokeAgent(address _agent) external onlyOwner {\r\n        authorizedAgents[_agent] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Pause the contract\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause the contract\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw (only if contract is paused)\r\n     * @notice This should only be used in extreme circumstances\r\n     */\r\n    function emergencyWithdraw() external onlyOwner {\r\n        if (!paused()) revert ContractMustBePaused();\r\n        \r\n        if (data.escrowDetails.assetToken == address(0)) {\r\n            (bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\r\n            if (!success) revert EmergencyWithdrawFailed();\r\n        } else {\r\n            IERC20 token = IERC20(data.escrowDetails.assetToken);\r\n            token.safeTransfer(owner(), token.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    // Internal Functions\r\n\r\n    /**\r\n     * @dev Internal function to release funds\r\n     * @param _recipient Address to receive the funds\r\n     */\r\n    function _releaseFunds(address _recipient) internal {\r\n        if (data.escrowDetails.state != EscrowState.AWAITING_FULFILLMENT && \r\n            data.escrowDetails.state != EscrowState.DISPUTE_RAISED) {\r\n            revert InvalidStateForFundRelease();\r\n        }\r\n\r\n        uint256 amount = data.escrowDetails.assetAmount;\r\n        uint256 platformFee = (amount * data.platformFeePercentage) / data.feeDenominator;\r\n        uint256 arbiterFee = (amount * data.arbiterFeePercentage) / data.feeDenominator;\r\n        uint256 netAmount = (amount - platformFee) - arbiterFee;\r\n        uint currentTime = _now();\r\n        data.escrowDetails.state = _recipient == data.escrowDetails.seller ? \r\n            EscrowState.COMPLETED : EscrowState.CANCELED;\r\n        data.escrowDetails.updatedAt = currentTime;\r\n\r\n        if (data.escrowDetails.assetToken == address(0)) {\r\n            // Native token (ETH)\r\n            if (netAmount > 0) {\r\n                (bool success, ) = payable(_recipient).call{value: netAmount}(\"\");\r\n                if (!success) revert TransferToRecipientFailed();\r\n            }\r\n            if (platformFee > 0) {\r\n                (bool success, ) = payable(data.platformFeeRecipient).call{value: platformFee}(\"\");\r\n                if (!success) revert TransferToPlatformFailed();\r\n            }\r\n            if (arbiterFee > 0) {\r\n                (bool success, ) = payable(data.escrowDetails.arbiter).call{value: arbiterFee}(\"\");\r\n                if (!success) revert TransferToArbiterFailed();\r\n            }\r\n        } else {\r\n            // ERC20 token\r\n            IERC20 token = IERC20(data.escrowDetails.assetToken);\r\n            \r\n            if (netAmount > 0) {\r\n                token.safeTransfer(_recipient, netAmount);\r\n            }\r\n            if (platformFee > 0) {\r\n                token.safeTransfer(data.platformFeeRecipient, platformFee);\r\n            }\r\n            if (arbiterFee > 0) {\r\n                token.safeTransfer(data.escrowDetails.arbiter, arbiterFee);\r\n            }\r\n        }\r\n\r\n        if(data.escrowDetails.arbiter != address(0)) {\r\n            require(IEscrowFactory(owner()).updateArbiterStatus(data.escrowDetails.arbiter), \"Update failed\");\r\n        }\r\n\r\n        emit FundsReleased(_recipient, data.escrowDetails.assetToken, netAmount, currentTime);\r\n    } \r\n\r\n}\r\n"
      },
      "project/contracts/escrow/EscrowFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.30;\r\n\r\nimport { Escrow } from \"./Escrow.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport { IEscrowFactory } from \"../interfaces/IEscrowFactory.sol\";\r\nimport { IArbitrators } from \"../interfaces/IArbitrators.sol\";\r\n\r\n/**\r\n * @title EscrowFactory contract\r\n * @dev Factory contract for creating escrow instances\r\n * @author @bobeu : https://github.com/bobeu\r\n */\r\ncontract EscrowFactory is IEscrowFactory, Ownable, Pausable, ReentrancyGuard {\r\n\r\n    // State Variables\r\n    address[] internal escrows;\r\n\r\n    IArbitrators internal arbitrator;\r\n\r\n    mapping(address => bool) internal isEscrow;\r\n\r\n    mapping(address => address[]) internal userEscrows;\r\n\r\n    mapping(address arbiter => uint8) internal escrowAtHand;\r\n    \r\n    address internal platformFeeRecipient;\r\n\r\n    uint256 internal defaultDisputeWindowHours = 24; // 24 hours default\r\n\r\n    uint256 internal totalEscrowsCreated;\r\n    \r\n    // Escrow creation fee (in wei)\r\n    uint256 internal creationFee = 0.001 ether;\r\n\r\n    // Modifiers\r\n    modifier onlyValidAddress(address _addr) {\r\n        if (_addr == address(0)) revert InvalidAddress();\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidAmount(uint256 _amount) {\r\n        if (_amount == 0) revert AmountMustBeGreaterThanZero();\r\n        _;\r\n    }\r\n\r\n    modifier validDeadline(uint256 _deadline) {\r\n        if (_deadline <= block.timestamp) revert DeadlineMustBeInTheFuture();\r\n        _;\r\n    }\r\n\r\n    modifier validDisputeWindow(uint256 _window) {\r\n        if (_window == 0) revert DisputeWindowMustBeGreaterThanZero();\r\n        if (_window > 168) revert DisputeWindowCannotExceedSevenDays();\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidEscrow(address _escrowAddress) {\r\n        if (!isEscrow[_escrowAddress]) revert InvalidEscrowAddress();\r\n        _;\r\n    }\r\n\r\n    // Constructor\r\n    constructor(\r\n        address _platformFeeRecipient,\r\n        IArbitrators _arbitrator\r\n    ) \r\n        onlyValidAddress(_platformFeeRecipient) \r\n        onlyValidAddress(address(_arbitrator)) \r\n        Ownable(_msgSender()) \r\n    {\r\n        platformFeeRecipient = _platformFeeRecipient;\r\n        arbitrator = _arbitrator;\r\n    }\r\n\r\n    \r\n    // Receive function for ETH\r\n    receive() external payable {\r\n        // This function allows the contract to receive ETH\r\n    }\r\n\r\n    /**\r\n     * @dev Validate escrow creation parameters\r\n     */\r\n    function _validateEscrowParams(\r\n        address _buyer,\r\n        address _seller,\r\n        string memory _description,\r\n        uint256 valueSent\r\n    ) internal view {\r\n        if(valueSent < creationFee) revert InsufficientCreationFee(valueSent);\r\n        if(bytes(_description).length == 0) revert DescriptionCannotBeEmpty();\r\n        if(_buyer == _seller) revert BuyerAndSellerCannotBeTheSame();\r\n    }\r\n\r\n    /**\r\n     * @dev Create and deploy new escrow contract\r\n     */\r\n    function _deployEscrow(\r\n        address _buyer,\r\n        address _seller,\r\n        address _assetToken,\r\n        uint256 _assetAmount,\r\n        uint256 _deadline,\r\n        string memory _description,\r\n        uint256 _disputeWindowHours\r\n    ) internal returns (address) {\r\n        return address(new Escrow(\r\n            _buyer,\r\n            _seller,\r\n            _assetToken,\r\n            _assetAmount,\r\n            _deadline,\r\n            _description,\r\n            _disputeWindowHours,\r\n            platformFeeRecipient\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Register escrow in factory mappings\r\n     */\r\n    function _registerEscrow(\r\n        address _escrowAddress,\r\n        address _buyer,\r\n        address _seller\r\n    ) internal {\r\n        escrows.push(_escrowAddress);\r\n        isEscrow[_escrowAddress] = true;\r\n        userEscrows[_buyer].push(_escrowAddress);\r\n        userEscrows[_seller].push(_escrowAddress);\r\n        totalEscrowsCreated++;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer creation fee to platform\r\n     */\r\n    function _transferCreationFee(uint256 valueSent) internal {\r\n        if (valueSent > 0) {\r\n            (bool sent,) = platformFeeRecipient.call{value:valueSent}('');\r\n            if(!sent) revert ErrorSendingToPlatformFeeRecipient();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new escrow contract - Internal function\r\n     * @param _buyer Address of the buyer\r\n     * @param _seller Address of the seller\r\n     * @param _assetToken Address of the asset token (address(0) for ETH)\r\n     * @param _assetAmount Amount of assets to escrow\r\n     * @param _deadline Unix timestamp when escrow expires\r\n     * @param _description Description of the escrow\r\n     * @param _disputeWindowHours Hours within which disputes can be raised\r\n     * @notice With this model, an user can have multiple escrows running simultaneously\r\n     */\r\n    function _createEscrow(\r\n        address _buyer,\r\n        address _seller,\r\n        address _assetToken,\r\n        uint256 _assetAmount,\r\n        uint256 _deadline,\r\n        string memory _description,\r\n        uint256 _disputeWindowHours,\r\n        uint256 valueSent\r\n    ) \r\n        internal \r\n        nonReentrant \r\n        whenNotPaused\r\n        onlyValidAddress(_buyer)\r\n        onlyValidAddress(_seller)\r\n        onlyValidAmount(_assetAmount)\r\n        validDeadline(_deadline)\r\n        validDisputeWindow(_disputeWindowHours)\r\n    {\r\n        _validateEscrowParams(_buyer, _seller, _description, valueSent);\r\n        \r\n        address escrowAddress = _deployEscrow(\r\n            _buyer,\r\n            _seller,\r\n            _assetToken,\r\n            _assetAmount,\r\n            _deadline,\r\n            _description,\r\n            _disputeWindowHours\r\n        );\r\n        \r\n        _registerEscrow(escrowAddress, _buyer, _seller);\r\n        _transferCreationFee(valueSent);\r\n\r\n        emit EscrowCreated(\r\n            escrowAddress,\r\n            _buyer,\r\n            _seller,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    ///@dev See _createEscrow\r\n    function createEscrow(\r\n        address _buyer,\r\n        address _seller,\r\n        address _assetToken,\r\n        uint256 _assetAmount,\r\n        uint256 _deadline,\r\n        string memory _description,\r\n        uint256 _disputeWindowHours\r\n    ) \r\n        external \r\n        payable \r\n        returns (bool) \r\n    {\r\n        _createEscrow(_buyer, _seller, _assetToken, _assetAmount, _deadline, _description, _disputeWindowHours, msg.value);\r\n        return true;\r\n    }\r\n\r\n    /**                          \r\n     * @dev Create escrow with default dispute window\r\n     * @param _buyer Address of the buyer\r\n     * @param _seller Address of the seller\r\n     * @param _assetToken Address of the asset token (address(0) for ETH)\r\n     * @param _assetAmount Amount of assets to escrow\r\n     * @param _deadline Unix timestamp when escrow expires\r\n     * @param _description Description of the escrow\r\n     * @return escrowAddress Address of the created escrow contract\r\n     */\r\n    function createEscrowWithDefaultWindow(\r\n        address _buyer,\r\n        address _seller,\r\n        address _assetToken,\r\n        uint256 _assetAmount,\r\n        uint256 _deadline,\r\n        string memory _description\r\n    ) \r\n        external \r\n        payable \r\n        returns (bool)\r\n    {\r\n        _createEscrow(\r\n            _buyer, \r\n            _seller, \r\n            _assetToken, \r\n            _assetAmount, \r\n            _deadline, \r\n            _description, \r\n            defaultDisputeWindowHours, \r\n            msg.value\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // Read escrow data\r\n    function getData(address _user) external view returns(ReadData memory) {\r\n        return ReadData(\r\n            escrows,\r\n            userEscrows[_user],\r\n            totalEscrowsCreated,\r\n            userEscrows[_user].length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get all escrows created by this factory\r\n     * @return Array of escrow addresses\r\n     */\r\n    function getAllEscrows() external view returns (address[] memory) {\r\n        return escrows;\r\n    }\r\n\r\n    /**\r\n     * @dev Get escrows for a specific user\r\n     * @param _user User address\r\n     * @return Array of escrow addresses\r\n     */\r\n    function getUserEscrows(address _user) external view returns (address[] memory) {\r\n        return userEscrows[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get total number of escrows created\r\n     * @return Total count\r\n     */\r\n    function getTotalEscrows() external view returns (uint256) {\r\n        return totalEscrowsCreated;\r\n    }\r\n\r\n    /**\r\n     * @dev Get escrow count for a specific user\r\n     * @param _user User address\r\n     * @return Count of escrows\r\n     */\r\n    function getUserEscrowCount(address _user) external view returns (uint256) {\r\n        return userEscrows[_user].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address is a valid escrow\r\n     * @param _escrowAddress Address to check\r\n     * @return True if valid escrow\r\n     */\r\n    function isValidEscrow(address _escrowAddress) external view returns (bool) {\r\n        return isEscrow[_escrowAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Get escrow details by address\r\n     * @param _escrowAddress Address of the escrow\r\n     * @return Escrow details\r\n     */\r\n    function getEscrowDetails(address payable _escrowAddress) \r\n        external \r\n        view \r\n        onlyValidEscrow(_escrowAddress)\r\n        returns (Escrow.EscrowDetails memory) \r\n    {\r\n        return Escrow(_escrowAddress).getEscrowData().escrowDetails;\r\n    }\r\n\r\n    /**\r\n     * @dev Get escrow state by address\r\n     * @param _escrowAddress Address of the escrow\r\n     * @return Escrow state\r\n     */\r\n    function getEscrowState(address payable _escrowAddress) \r\n        external \r\n        view \r\n        onlyValidEscrow(_escrowAddress)\r\n        returns (Escrow.EscrowState) \r\n    {\r\n        return Escrow(_escrowAddress).getEscrowData().escrowDetails.state;\r\n    }\r\n\r\n    /**\r\n     * @dev Get paginated escrows\r\n     * @param _offset Starting index\r\n     * @param _limit Number of escrows to return\r\n     * @return Array of escrow addresses\r\n     */\r\n    function getEscrowsPaginated(uint256 _offset, uint256 _limit) \r\n        external \r\n        view \r\n        returns (address[] memory) \r\n    {\r\n        if (_offset >= escrows.length) revert OffsetOutOfBounds();\r\n        \r\n        uint256 end = _offset + _limit;\r\n        if (end > escrows.length) {\r\n            end = escrows.length;\r\n        }\r\n        \r\n        address[] memory result = new address[](end - _offset);\r\n        for (uint256 i = _offset; i < end; i++) {\r\n            result[i - _offset] = escrows[i];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    function getArbiterStatus(address arbiter) external view returns(bool, uint8 num) {\r\n        num = escrowAtHand[arbiter];\r\n        return (num > 0, num);\r\n    }\r\n\r\n    function isApprovedArbiter(address arbiter, uint8 flag) external onlyValidEscrow(_msgSender()) returns(bool) {\r\n        bool isApproved = arbitrator.isApprovedArbiter(arbiter);\r\n        if(flag == 1 && isApproved) {\r\n            unchecked {\r\n                escrowAtHand[arbiter] += flag;\r\n            }\r\n            userEscrows[arbiter].push(_msgSender());\r\n        }\r\n        return isApproved;\r\n    }\r\n\r\n    function updateArbiterStatus(address arbiter) external onlyValidEscrow(_msgSender()) returns(bool) {\r\n        if(arbiter != address(0)) {\r\n            unchecked {\r\n                if(escrowAtHand[arbiter] > 0) escrowAtHand[arbiter] -= 1;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Admin Functions\r\n\r\n    /**\r\n     * @dev Update platform fee recipient\r\n     * @param _newRecipient New platform fee recipient address\r\n     */\r\n    function updatePlatformFeeRecipient(address _newRecipient) \r\n        external \r\n        onlyOwner \r\n        onlyValidAddress(_newRecipient) \r\n    {\r\n        address oldRecipient = platformFeeRecipient;\r\n        platformFeeRecipient = _newRecipient;\r\n        \r\n        emit PlatformFeeRecipientUpdated(oldRecipient, _newRecipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Update default dispute window\r\n     * @param _newWindow New default dispute window in hours\r\n     */\r\n    function updateDefaultDisputeWindow(uint256 _newWindow) \r\n        external \r\n        onlyOwner \r\n        validDisputeWindow(_newWindow) \r\n    {\r\n        uint256 oldWindow = defaultDisputeWindowHours;\r\n        defaultDisputeWindowHours = _newWindow;\r\n        \r\n        emit DefaultDisputeWindowUpdated(oldWindow, _newWindow);\r\n    }\r\n\r\n    /**\r\n     * @dev Update creation fee\r\n     * @param _newFee New creation fee in wei\r\n     */\r\n    function updateCreationFee(uint256 _newFee) external onlyOwner {\r\n        creationFee = _newFee;\r\n    }\r\n\r\n    /**\r\n     * @dev Pause the factory\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause the factory\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw (only if contract is paused)\r\n     * @notice This should only be used in extreme circumstances\r\n     */\r\n    function emergencyWithdraw() external onlyOwner returns(bool) {\r\n        if (!paused()) revert ContractMustBePaused();\r\n        (bool sent,) = owner().call{value: address(this).balance}('');\r\n        if (!sent) revert WithdrawalFailed();\r\n        return true;\r\n    }\r\n}\r\n"
      },
      "project/contracts/interfaces/IArbitrators.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.30;\r\n\r\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IEscrowFactory } from \"./IEscrowFactory.sol\";\r\n\r\n/**\r\n * @title IArbitrators\r\n * @dev Interface of the Arbitrators contract\r\n * @author Bobeu - https://github.com/bobeu\r\n */\r\ninterface IArbitrators {\r\n    struct Arbiter {\r\n        bytes32 id;\r\n        uint256 lockedBalance;\r\n        bool isApproved;\r\n        uint lastSeen;\r\n        address identifier;\r\n    }\r\n\r\n    struct Request {\r\n        bool hasRequested;\r\n        uint index;\r\n    }\r\n\r\n    struct ReadData {\r\n        Arbiter[] arbiters;\r\n        IERC20 verseToken;\r\n        IEscrowFactory factory;\r\n        uint256 minimumAbiterHolding;\r\n    }\r\n\r\n    function getArbiter(bytes32 arbiterId) external view returns(Arbiter memory);\r\n    function requestToBeAnArbiter() external returns(bool);\r\n    function isApprovedArbiter(address arbiter) external view returns(bool);\r\n\r\n    error VerseTokenNotSet();\r\n    error Requested();\r\n    error NoRequestFound();\r\n    error FactoryNotSet();\r\n    error NotApproved();\r\n    error NoBalance();\r\n    error CooldownMode();\r\n    error ArbiterIsEngaged();\r\n    error AribterAlreadyApproved();\r\n    error MinimumAbiterHoldingExceedAllowance();\r\n}"
      },
      "project/contracts/interfaces/IEscrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.30;\r\n\r\n/**\r\n * @title IEscrow \r\n * @dev Interface for the Escrow contract\r\n * @author Bobeu - https://github.com/bobeu\r\n */\r\ninterface IEscrow {\r\n        // Custom Errors\r\n    error InvalidBuyerAddress();\r\n    error InvalidSellerAddress();\r\n    error InvalidArbiterAddress();\r\n    error AssetAmountMustBeGreaterThanZero();\r\n    error DeadlineMustBeInTheFuture();\r\n    error DisputeWindowMustBeGreaterThanZero();\r\n    error InvalidPlatformFeeRecipient();\r\n    error OnlyBuyerOrSellerCanCall();\r\n    error OnlyBuyerCanCall();\r\n    error OnlySellerCanCall();\r\n    error OnlyArbiterCanCall();\r\n    error OnlyAuthorizedAgentsCanCall();\r\n    error InvalidEscrowState();\r\n    error EscrowHasExpired();\r\n    error EscrowHasNotExpired();\r\n    error IncorrectETHAmount();\r\n    error ETHNotAcceptedForERC20Escrow();\r\n    error InsufficientTokenBalance();\r\n    error InsufficientTokenAllowance();\r\n    error OnlyBuyerOrArbiterCanReleaseFunds();\r\n    error OnlyBuyerOrArbiterCanRefundFunds();\r\n    error DeadlineNotReached();\r\n    error DisputeReasonCannotBeEmpty();\r\n    error NoActiveDispute();\r\n    error ReasoningCannotBeEmpty();\r\n    error InvalidStateForFundRelease();\r\n    error TransferToRecipientFailed();\r\n    error TransferToPlatformFailed();\r\n    error TransferToArbiterFailed();\r\n    error InvalidAgentAddress();\r\n    error ContractMustBePaused();\r\n    error EmergencyWithdrawFailed();\r\n    error ArbiterSwapWindowNotOpen();\r\n    error EscrowWasResolved();\r\n    error NotApproved();\r\n    error CallerIsTheArbiter();\r\n\r\n    // Events\r\n    event ArbiterSwapped(\r\n        address indexed oldArbiter,\r\n        address indexed newArbiter\r\n    );\r\n\r\n    event EscrowCreated(\r\n        address indexed buyer,\r\n        address indexed seller,\r\n        address indexed arbiter,\r\n        address assetToken,\r\n        uint256 assetAmount,\r\n        uint256 deadline\r\n    );\r\n    \r\n    event AssetDeposited(\r\n        address indexed depositor,\r\n        address indexed assetToken,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event FulfillmentConfirmed(\r\n        address indexed confirmer,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event FundsReleased(\r\n        address indexed recipient,\r\n        address indexed assetToken,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event FundsRefunded(\r\n        address indexed recipient,\r\n        address indexed assetToken,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event DisputeRaised(\r\n        address indexed disputer,\r\n        string reason,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event DisputeResolved(\r\n        address indexed arbiter,\r\n        bool releaseFunds,\r\n        string reasoning,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // Enums\r\n    enum EscrowState {\r\n        AWAITING_DEPOSIT,\r\n        AWAITING_FULFILLMENT,\r\n        DISPUTE_RAISED,\r\n        COMPLETED,\r\n        CANCELED\r\n    }\r\n\r\n    // Structs\r\n    struct EscrowDetails {\r\n        address buyer;\r\n        address seller;\r\n        address arbiter;\r\n        address assetToken;\r\n        uint256 assetAmount;\r\n        uint256 deadline;\r\n        EscrowState state;\r\n        uint256 createdAt;\r\n        uint256 updatedAt;\r\n        string description;\r\n        uint256 disputeWindowHours;\r\n    }\r\n\r\n    struct DisputeInfo {\r\n        bool isActive;\r\n        address disputer;\r\n        bytes reason;\r\n        uint256 raisedAt;\r\n        address arbiter;\r\n        bool arbiterDecision;\r\n        bytes arbiterReasoning;\r\n        uint256 resolvedAt;\r\n    }\r\n\r\n    struct EscrowData {\r\n        EscrowDetails escrowDetails;\r\n        DisputeInfo disputeInfo;\r\n        uint256 platformFeePercentage; // 50 = 0.5%\r\n        uint256 arbiterFeePercentage; // 100 = 1%\r\n        uint256 feeDenominator; // default is 10000\r\n        address platformFeeRecipient;\r\n    }\r\n\r\n}"
      },
      "project/contracts/interfaces/IEscrowFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.30;\r\n\r\n/**\r\n * @title IEscrowFactory\r\n * @dev Interface of the EscrowFactory contract\r\n * @author Bobeu - https://github.com/bobeu\r\n */\r\ninterface IEscrowFactory {\r\n        //Errors\r\n    error InsufficientCreationFee(uint256 valueSent);\r\n    error DescriptionCannotBeEmpty();\r\n    error BuyerAndSellerCannotBeTheSame();\r\n    error BuyerAndArbiterCannotBeTheSame();\r\n    error SellerAndArbiterCannotBeTheSame();\r\n    error ErrorSendingToPlatformFeeRecipient();\r\n    error InvalidAddress();\r\n    error AmountMustBeGreaterThanZero();\r\n    error DeadlineMustBeInTheFuture();\r\n    error DisputeWindowMustBeGreaterThanZero();\r\n    error DisputeWindowCannotExceedSevenDays();\r\n    error InvalidEscrowAddress();\r\n    error OffsetOutOfBounds();\r\n    error WithdrawalFailed();\r\n    error ContractMustBePaused();\r\n\r\n    // Events\r\n    event EscrowCreated(\r\n        address indexed escrowAddress,\r\n        address indexed buyer,\r\n        address indexed seller,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event PlatformFeeRecipientUpdated(\r\n        address indexed oldRecipient,\r\n        address indexed newRecipient\r\n    );\r\n\r\n    event DefaultDisputeWindowUpdated(\r\n        uint256 oldWindow,\r\n        uint256 newWindow\r\n    );\r\n\r\n    struct ReadData {\r\n        address[] allEscrow;\r\n        address[] userEscrows;\r\n        uint totalEscrows;\r\n        uint userEscrowCount;\r\n    }\r\n\r\n   function getArbiterStatus(address arbiter) external view returns(bool, uint8 num);\r\n   function updateArbiterStatus(address arbiter) external returns(bool);\r\n   function isApprovedArbiter(address arbiter, uint8 flag) external returns(bool);\r\n\r\n}"
      }
    }
  }
}